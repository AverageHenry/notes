{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Obsidian Notes \u00b6 Publish your public notes with MkDocs Hello World! \u00b6 The index.md in the /docs folder is the homepage you see here. The folders in /docs appear as the main sections on the navigation bar. The notes appear as pages within these sections. For example, Note 1 in Topic 1 Test","title":"Obsidian Notes"},{"location":"#obsidian-notes","text":"Publish your public notes with MkDocs","title":"Obsidian Notes"},{"location":"#hello-world","text":"The index.md in the /docs folder is the homepage you see here. The folders in /docs appear as the main sections on the navigation bar. The notes appear as pages within these sections. For example, Note 1 in Topic 1 Test","title":"Hello World!"},{"location":"Recursion%20Foundations/Combinations/","text":"Combinations - C(n, k) \u00b6 Number of ways to choose k objects out of n, where repetition is not allowed and order is also not important? C(n, k) = The number of subsets of size k we can create out of n elements. C(n, n) = ? C(n, 0) = ? [!NOTE] Pascal's Triangle is a great example to show how combinations are calculated.","title":"Combinations - C(n, k)"},{"location":"Recursion%20Foundations/Combinations/#combinations-cn-k","text":"Number of ways to choose k objects out of n, where repetition is not allowed and order is also not important? C(n, k) = The number of subsets of size k we can create out of n elements. C(n, n) = ? C(n, 0) = ? [!NOTE] Pascal's Triangle is a great example to show how combinations are calculated.","title":"Combinations - C(n, k)"},{"location":"Recursion%20Foundations/Combinatorial%20Enumeration%20Binary%20Strings/","text":"Combinatorial Enumeration Binary Strings \u00b6 Given a set of n distinct objects, enumerate all possible 'combinatorial objects': \u00b6 Can be Permutations or Combinations If ordering matters, we will use permutations. Repetitions allowed or No repetitions allowed If ordering doesn't matter, we will use combinations/subsets. Example: Enumerate/print all possible binary strings of length n. \u00b6 ![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220410143338.png]] This can be done Iteratively and Recursively using BFS. While the time complexity would be 2 n x n, the space complexity would be 2 n , which is a lot. Consider Recursive DFS instead: ![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220410150210.png]] Using Recursive DFS would still give us a time complexity of 2 n x n, but our space will be significantly reduced to n, since there would be no more than n function calls in our call stack at any point in time.","title":"Combinatorial Enumeration Binary Strings"},{"location":"Recursion%20Foundations/Combinatorial%20Enumeration%20Binary%20Strings/#combinatorial-enumeration-binary-strings","text":"","title":"Combinatorial Enumeration Binary Strings"},{"location":"Recursion%20Foundations/Combinatorial%20Enumeration%20Binary%20Strings/#given-a-set-of-n-distinct-objects-enumerate-all-possible-combinatorial-objects","text":"Can be Permutations or Combinations If ordering matters, we will use permutations. Repetitions allowed or No repetitions allowed If ordering doesn't matter, we will use combinations/subsets.","title":"Given a set of n distinct objects, enumerate all possible 'combinatorial objects':"},{"location":"Recursion%20Foundations/Combinatorial%20Enumeration%20Binary%20Strings/#example-enumerateprint-all-possible-binary-strings-of-length-n","text":"![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220410143338.png]] This can be done Iteratively and Recursively using BFS. While the time complexity would be 2 n x n, the space complexity would be 2 n , which is a lot. Consider Recursive DFS instead: ![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220410150210.png]] Using Recursive DFS would still give us a time complexity of 2 n x n, but our space will be significantly reduced to n, since there would be no more than n function calls in our call stack at any point in time.","title":"Example: Enumerate/print all possible binary strings of length n."},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/","text":"Printing All Permutations \u00b6 Printing Permutations With Repetitions Allowed \u00b6 Example: Print all decimal strings of length n. \u00b6 def decimal_strings_of_length_n(n): def dshelper(slate): # Base Case: if len(slate) == n: print(slate) else: # Recursive case # Test for digits 0-9 for i in range(10): slate.append(i) dshelper(slate) slate.pop() # Call helper function from the top manager's perspective dshelper([]) Time: O (10 n x n) Space: O (n) Printing Permutations Without Repetitions \u00b6 Example: Given a set (or string) of n distinct characters, print all permutations (of size n, no repetitions allowed) \u00b6 ![[content/Interview Kickstart Notes/Recursion Foundations/Images/permutations_no_duplicates.png]] Time: O (n! x n) --> Since repetition is not allowed in our input, the number of possibilities is n!, since n x n-1 x n-2 x ... 1 == n!. We know that we will have n! leaf nodes, and each leaf node is doing n work (printing the slate of length n), so the total work being done is n! x n. Space: O (n) --> This is recursive DFS. We only use the call stack, and we know our call stack cannot contain more than n function calls for this algorithm.","title":"Printing All Permutations"},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/#printing-all-permutations","text":"","title":"Printing All Permutations"},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/#printing-permutations-with-repetitions-allowed","text":"","title":"Printing Permutations With Repetitions Allowed"},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/#example-print-all-decimal-strings-of-length-n","text":"def decimal_strings_of_length_n(n): def dshelper(slate): # Base Case: if len(slate) == n: print(slate) else: # Recursive case # Test for digits 0-9 for i in range(10): slate.append(i) dshelper(slate) slate.pop() # Call helper function from the top manager's perspective dshelper([]) Time: O (10 n x n) Space: O (n)","title":"Example: Print all decimal strings of length n."},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/#printing-permutations-without-repetitions","text":"","title":"Printing Permutations Without Repetitions"},{"location":"Recursion%20Foundations/Printing%20All%20Permutations/#example-given-a-set-or-string-of-n-distinct-characters-print-all-permutations-of-size-n-no-repetitions-allowed","text":"![[content/Interview Kickstart Notes/Recursion Foundations/Images/permutations_no_duplicates.png]] Time: O (n! x n) --> Since repetition is not allowed in our input, the number of possibilities is n!, since n x n-1 x n-2 x ... 1 == n!. We know that we will have n! leaf nodes, and each leaf node is doing n work (printing the slate of length n), so the total work being done is n! x n. Space: O (n) --> This is recursive DFS. We only use the call stack, and we know our call stack cannot contain more than n function calls for this algorithm.","title":"Example: Given a set (or string) of n distinct characters, print all permutations (of size n, no repetitions allowed)"},{"location":"Recursion%20Foundations/Printing%20Subsets/","text":"Printing Subsets \u00b6 From permutations to combinations: \u00b6 Example: Given a set of n distinct numbers, print(enumerate) all of its subsets. \u00b6 You can use an inclusion/exclusion choice pattern for subsets/combinations. _ _ _ _ ! 2x2x2x2 possibilities, so if we have an input of size n, our time complexity would be 2 n .","title":"Printing Subsets"},{"location":"Recursion%20Foundations/Printing%20Subsets/#printing-subsets","text":"","title":"Printing Subsets"},{"location":"Recursion%20Foundations/Printing%20Subsets/#from-permutations-to-combinations","text":"","title":"From permutations to combinations:"},{"location":"Recursion%20Foundations/Printing%20Subsets/#example-given-a-set-of-n-distinct-numbers-printenumerate-all-of-its-subsets","text":"You can use an inclusion/exclusion choice pattern for subsets/combinations. _ _ _ _ ! 2x2x2x2 possibilities, so if we have an input of size n, our time complexity would be 2 n .","title":"Example: Given a set of n distinct numbers, print(enumerate) all of its subsets."},{"location":"Recursion%20Foundations/Recursion%20as%20a%20Lazy%20Manager%27s%20Strategy/","text":"Recursion as a Lazy Manager's Strategy \u00b6 Recursion \u00b6 Solving large problems by reducing them to smaller problems of the same form . Reduce a large problem to one or more subproblems that are - Identical in nature - Somewhat simpler to solve Then use the same decomposition technique to divide the subproblems into new ones that are even simpler... until they become so simple that you can solve them without further subdivision. Reassemble the solved components to obtain the complete solution to the original problem. ![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220409150029.png]] Question: How many subsets of a set of size n are there? \u00b6 There are 2 n subsets. {} -> {} 1 {a} --> {}, {a} 2 {a, b} --> {}, {a}, {b}, {a, b} 4 ...","title":"Recursion as a Lazy Manager's Strategy"},{"location":"Recursion%20Foundations/Recursion%20as%20a%20Lazy%20Manager%27s%20Strategy/#recursion-as-a-lazy-managers-strategy","text":"","title":"Recursion as a Lazy Manager's Strategy"},{"location":"Recursion%20Foundations/Recursion%20as%20a%20Lazy%20Manager%27s%20Strategy/#recursion","text":"Solving large problems by reducing them to smaller problems of the same form . Reduce a large problem to one or more subproblems that are - Identical in nature - Somewhat simpler to solve Then use the same decomposition technique to divide the subproblems into new ones that are even simpler... until they become so simple that you can solve them without further subdivision. Reassemble the solved components to obtain the complete solution to the original problem. ![[content/Interview Kickstart Notes/Recursion Foundations/Images/Pasted image 20220409150029.png]]","title":"Recursion"},{"location":"Recursion%20Foundations/Recursion%20as%20a%20Lazy%20Manager%27s%20Strategy/#question-how-many-subsets-of-a-set-of-size-n-are-there","text":"There are 2 n subsets. {} -> {} 1 {a} --> {}, {a} 2 {a, b} --> {}, {a}, {b}, {a, b} 4 ...","title":"Question: How many subsets of a set of size n are there?"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/","text":"Recursive Mathematical Functions - Factorials for Permutations \u00b6 Basic Combinatorics \u00b6 The Factorial Function \u00b6 How many ways can you arrange n different objects in a straight line? Example: [a, b, c, d] would have 4 x 3 x 2 x 1 different ways. n x (n - 1) x (n - 2) x (n - 3) x ... x 1 = n! This is known as a Permutation . The number of permutations for n objects is n!. So far, no repetitions have been allowed. What if they were? If repetitions were allowed, [a, b, c, d] would have 4 x 4 x 4 x 4 different ways. n x n x n x ... x n = n n This is known as an Arrangement . The number of arrangements possible for n objects is n n . Example: How many binary strings of length n are possible? 2 x 2 x 2 x 2 x 2 x ... x 2 = 2 n How about the number of 4-digit passcodes that are possible? 10 x 10 x 10 x 10 = 10 4 Calculating the value of n! using [[content/Interview Kickstart Notes/Design Strategies/Decrease & Conquer]] \u00b6 Top-down Recursive Solution \u00b6 def fact(n): if n == 0: return 1 else: # Chip away at the problem by reducing it to size - 1 # Ask worker clone to solve the smaller problem # Construct the solution to the overall problem using that return n * fact(n - 1) Bottom-up Iterative Solution \u00b6 def fact(n): result = 1 for i in range(1, n): result *= i return result","title":"Recursive Mathematical Functions - Factorials for Permutations"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#recursive-mathematical-functions-factorials-for-permutations","text":"","title":"Recursive Mathematical Functions - Factorials for Permutations"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#basic-combinatorics","text":"","title":"Basic Combinatorics"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#the-factorial-function","text":"How many ways can you arrange n different objects in a straight line? Example: [a, b, c, d] would have 4 x 3 x 2 x 1 different ways. n x (n - 1) x (n - 2) x (n - 3) x ... x 1 = n! This is known as a Permutation . The number of permutations for n objects is n!. So far, no repetitions have been allowed. What if they were? If repetitions were allowed, [a, b, c, d] would have 4 x 4 x 4 x 4 different ways. n x n x n x ... x n = n n This is known as an Arrangement . The number of arrangements possible for n objects is n n . Example: How many binary strings of length n are possible? 2 x 2 x 2 x 2 x 2 x ... x 2 = 2 n How about the number of 4-digit passcodes that are possible? 10 x 10 x 10 x 10 = 10 4","title":"The Factorial Function"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#calculating-the-value-of-n-using-contentinterview-kickstart-notesdesign-strategiesdecrease-conquer","text":"","title":"Calculating the value of n! using [[content/Interview Kickstart Notes/Design Strategies/Decrease &amp; Conquer]]"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#top-down-recursive-solution","text":"def fact(n): if n == 0: return 1 else: # Chip away at the problem by reducing it to size - 1 # Ask worker clone to solve the smaller problem # Construct the solution to the overall problem using that return n * fact(n - 1)","title":"Top-down Recursive Solution"},{"location":"Recursion%20Foundations/Recursive%20Mathematical%20Functions%20-%20Factorials%20for%20Permutations/#bottom-up-iterative-solution","text":"def fact(n): result = 1 for i in range(1, n): result *= i return result","title":"Bottom-up Iterative Solution"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/","text":"Recursion Lecture Notes \u00b6 Agenda \u00b6 Recursion is a bit of a misnomer for this lecture. - Recursion has been seen in sorting: Insertion Sort, Merge Sort, and QuickSort. - Recursion has been seen in searching: Binary Search. - Binary Trees are an example of a recursive data structure. It is easy to write recursive algorithms on recursive data structures. - You will see examples of recursion in Graphs and Dynamic Programming. With that being said, recursion pervades the whole curriculum . The distinctive thing about this lecture is that the \"class of problems\" that are going to be seen are Combinatorial Enumeration problems, with Backtracking problems as well. Writing recursive code for these problems is more tricky. Exhaustive Enumeration \u00b6 Exhaustive Enumeration requires a systematic enumeration/generation of all possible objects (permutation or combinations). This leads to a combinatorial explosion - exponential time complexity. Hence, this is impractical for even moderate input sizes . Still, for many problems of this nature, e cannot do better than this. Given a set of n objects, we: \u00b6 Sorted them ([[Sorting Overview]]). Will enumerate all permutations and combinations. How many permutaions are possible for a set of n distinct objects? \u00b6 n! --> n x (n - 1) x (n - 2) x ... x 1 How many combinations are possible for a set of n distinct objects? \u00b6 2 n General Template \u00b6 You have to fill in a series of blanks, and there is an exponential number of ways to do it. \" __\" This series of blanks represent a combinatorial object (some permutation or combination). You proceed left to right, and as a lazy manager, only take responsibility for filling in the first blank. Delegate the rest of the work to your subordinates. Write up a general strategy used by any arbitrary worker in the heirarchy as a recursive function. This is what the general template will look like in code: def helper(partial_solution, subproblem_definition): # partial_solution is a \"slate\" # Base Case: Leaf Worker if subproblem_definition is empty: # Partial solution is a complete P/C Add the complete solution to the \"global bag\" return # Recursive Case: Interal Node Workers else: # Let c1, c2, c3... ck be the number of choices for filling into the leftmost blank For each of those choices ci: Add ci to the slate (append) helper(enlarged_slate, smaller_subproblem) def overall(a_set_of_n_objects): result = [] helper(blank_slate, complete_problem_of_size_n) return result Question 1: Letter Case Permutation ([[www.google.com|Leetcode #784]]) \u00b6 ![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412000103.png]] [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/letter_case_permutations.png|Solution using a mutable slate]] \u00b6 Time Complexity: O (2 n x n) \u00b6 Space Complexity: O (n) \u00b6 Question 2: Subsets - No Duplicates \u00b6 ![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412010727.png]] [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/generate_subsets_no_repetition.png|Solution using mutable slate]] \u00b6 Question 3: Permutations - No Repetition \u00b6 ![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412110645.png]] [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/permutations_no_repetitions.png|Solution using a mutable slate]] \u00b6 Time Complexity: O (n! x n) Space Complexity: O (n! x n) Question 4: Permutations II - With Repetition \u00b6 ![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412130408.png]] [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/permutations_with_repetition.png|Solution:]] \u00b6 Solution would be the same as Permutations I. The only difference is you add a hashtable/hashset to see if we have already processed a number. If so, we continue, if not, we proceed to make a recursive call and then add the number to our hashtable/hashset. Time Complexity: O (n! x n) Space Complexity: O (n! x n) --> Keep in mind that in the worst case (all numbers are distinct), we store every number in the array into the hashtable at every level in our recursion tree, so that would take up n 2 space. NOTE: An alternative solution to this would be to sort the input beforehand and count the number of occurrences, then call the helper function based on the number of occurrences of the current number. We would then skip the duplicate values by passing i + count to the helper function. This approach would use less space, but take more time to run. Question 5: Subsets II - With Repetition \u00b6 ![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412141003.png]] [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/subsets_with_repetition.png|Solution]] \u00b6 Backtracking \u00b6 When we say backtracking in this case, we mean returning back to the calling function . It is an algorithm design strategy for adding constraints in a combinatorial enumeration problem. Sometimes, we can evaluate the the partially constructed solutions to a problem: - If none of the ways to fill in the remaining blanks can lead to a solution (or if we can identify the one, single solution that will emerge), we do not need to work to fill in the remaining blanks. - Instead, we backtrack from that internal node, thus pruning away the subtree rooted at it. This can be considered a Constraint Filter . To implement this, all we have to do is add a [[Pasted image 20220412162853.png|Backtracking Case]] to our recursion template. - Though it leads to an exponential improvement in combinatorial search, the resulting time is not polynomial, but an \"improved exponential time\" (it is difficult to give an exact expression for the time complexity). It is best treated as a heuristic rather than something amenable to worst-case analysis. Check out this [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Combinatorial Path.png|Combinatorial Path]]. It shows how cominatorial problems are built on top of one another.","title":"Recursion Lecture Notes"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#recursion-lecture-notes","text":"","title":"Recursion Lecture Notes"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#agenda","text":"Recursion is a bit of a misnomer for this lecture. - Recursion has been seen in sorting: Insertion Sort, Merge Sort, and QuickSort. - Recursion has been seen in searching: Binary Search. - Binary Trees are an example of a recursive data structure. It is easy to write recursive algorithms on recursive data structures. - You will see examples of recursion in Graphs and Dynamic Programming. With that being said, recursion pervades the whole curriculum . The distinctive thing about this lecture is that the \"class of problems\" that are going to be seen are Combinatorial Enumeration problems, with Backtracking problems as well. Writing recursive code for these problems is more tricky.","title":"Agenda"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#exhaustive-enumeration","text":"Exhaustive Enumeration requires a systematic enumeration/generation of all possible objects (permutation or combinations). This leads to a combinatorial explosion - exponential time complexity. Hence, this is impractical for even moderate input sizes . Still, for many problems of this nature, e cannot do better than this.","title":"Exhaustive Enumeration"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#given-a-set-of-n-objects-we","text":"Sorted them ([[Sorting Overview]]). Will enumerate all permutations and combinations.","title":"Given a set of n objects, we:"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#how-many-permutaions-are-possible-for-a-set-of-n-distinct-objects","text":"n! --> n x (n - 1) x (n - 2) x ... x 1","title":"How many permutaions are possible for a set of n distinct objects?"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#how-many-combinations-are-possible-for-a-set-of-n-distinct-objects","text":"2 n","title":"How many combinations are possible for a set of n distinct objects?"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#general-template","text":"You have to fill in a series of blanks, and there is an exponential number of ways to do it. \" __\" This series of blanks represent a combinatorial object (some permutation or combination). You proceed left to right, and as a lazy manager, only take responsibility for filling in the first blank. Delegate the rest of the work to your subordinates. Write up a general strategy used by any arbitrary worker in the heirarchy as a recursive function. This is what the general template will look like in code: def helper(partial_solution, subproblem_definition): # partial_solution is a \"slate\" # Base Case: Leaf Worker if subproblem_definition is empty: # Partial solution is a complete P/C Add the complete solution to the \"global bag\" return # Recursive Case: Interal Node Workers else: # Let c1, c2, c3... ck be the number of choices for filling into the leftmost blank For each of those choices ci: Add ci to the slate (append) helper(enlarged_slate, smaller_subproblem) def overall(a_set_of_n_objects): result = [] helper(blank_slate, complete_problem_of_size_n) return result","title":"General Template"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#question-1-letter-case-permutation-wwwgooglecomleetcode-784","text":"![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412000103.png]]","title":"Question 1: Letter Case Permutation ([[www.google.com|Leetcode #784]])"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#contentinterview-kickstart-notesrecursion-lecture-notesimagesletter_case_permutationspngsolution-using-a-mutable-slate","text":"","title":"[[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/letter_case_permutations.png|Solution using a mutable slate]]"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#time-complexity-o-2n-x-n","text":"","title":"Time Complexity: O (2n x n)"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#space-complexity-o-n","text":"","title":"Space Complexity: O (n)"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#question-2-subsets-no-duplicates","text":"![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412010727.png]]","title":"Question 2: Subsets - No Duplicates"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#contentinterview-kickstart-notesrecursion-lecture-notesimagesgenerate_subsets_no_repetitionpngsolution-using-mutable-slate","text":"","title":"[[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/generate_subsets_no_repetition.png|Solution using mutable slate]]"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#question-3-permutations-no-repetition","text":"![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412110645.png]]","title":"Question 3: Permutations - No Repetition"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#contentinterview-kickstart-notesrecursion-lecture-notesimagespermutations_no_repetitionspngsolution-using-a-mutable-slate","text":"Time Complexity: O (n! x n) Space Complexity: O (n! x n)","title":"[[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/permutations_no_repetitions.png|Solution using a mutable slate]]"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#question-4-permutations-ii-with-repetition","text":"![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412130408.png]]","title":"Question 4: Permutations II - With Repetition"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#contentinterview-kickstart-notesrecursion-lecture-notesimagespermutations_with_repetitionpngsolution","text":"Solution would be the same as Permutations I. The only difference is you add a hashtable/hashset to see if we have already processed a number. If so, we continue, if not, we proceed to make a recursive call and then add the number to our hashtable/hashset. Time Complexity: O (n! x n) Space Complexity: O (n! x n) --> Keep in mind that in the worst case (all numbers are distinct), we store every number in the array into the hashtable at every level in our recursion tree, so that would take up n 2 space. NOTE: An alternative solution to this would be to sort the input beforehand and count the number of occurrences, then call the helper function based on the number of occurrences of the current number. We would then skip the duplicate values by passing i + count to the helper function. This approach would use less space, but take more time to run.","title":"[[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/permutations_with_repetition.png|Solution:]]"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#question-5-subsets-ii-with-repetition","text":"![[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Pasted image 20220412141003.png]]","title":"Question 5: Subsets II - With Repetition"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#contentinterview-kickstart-notesrecursion-lecture-notesimagessubsets_with_repetitionpngsolution","text":"","title":"[[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/subsets_with_repetition.png|Solution]]"},{"location":"Recursion%20Lecture%20Notes/Recursion%20Notes/#backtracking","text":"When we say backtracking in this case, we mean returning back to the calling function . It is an algorithm design strategy for adding constraints in a combinatorial enumeration problem. Sometimes, we can evaluate the the partially constructed solutions to a problem: - If none of the ways to fill in the remaining blanks can lead to a solution (or if we can identify the one, single solution that will emerge), we do not need to work to fill in the remaining blanks. - Instead, we backtrack from that internal node, thus pruning away the subtree rooted at it. This can be considered a Constraint Filter . To implement this, all we have to do is add a [[Pasted image 20220412162853.png|Backtracking Case]] to our recursion template. - Though it leads to an exponential improvement in combinatorial search, the resulting time is not polynomial, but an \"improved exponential time\" (it is difficult to give an exact expression for the time complexity). It is best treated as a heuristic rather than something amenable to worst-case analysis. Check out this [[content/Interview Kickstart Notes/Recursion Lecture Notes/Images/Combinatorial Path.png|Combinatorial Path]]. It shows how cominatorial problems are built on top of one another.","title":"Backtracking"},{"location":"Sorting%20Foundations/Presorting/","text":"![[content/Interview Kickstart Notes/Sorting Foundations/Pasted image 20211115150934.png]] ![[content/Interview Kickstart Notes/Sorting Foundations/Pasted image 20211115152118.png]]","title":"Presorting"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/","text":"Counting Sort \u00b6 Use Case: \u00b6 Used to sort an array with many entries of 'small' values. Algorithm Overview: \u00b6 Create a data structure to count the occurrence of each number (or object). This will most likely be a [[Hash Table]] or an array of size k (ranging from min to max) initialized to all zeroes. After counting the frequency of values, loop over the keys in numerical order and add the key to an output list a number of times based on the frequency of the key. Return the output list. Time Complexity: O (n + k) \u00b6 Space Complexity: O (k) \u00b6 Where k is the # of keys in the hash table and n is the input size. What if we're dealing with objects where stability matters? (Student objects, for example): ![[content/Interview Kickstart Notes/Sorting Foundations/Pasted image 20211114233536.png]]","title":"Counting Sort"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/#counting-sort","text":"","title":"Counting Sort"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/#use-case","text":"Used to sort an array with many entries of 'small' values.","title":"Use Case:"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/#algorithm-overview","text":"Create a data structure to count the occurrence of each number (or object). This will most likely be a [[Hash Table]] or an array of size k (ranging from min to max) initialized to all zeroes. After counting the frequency of values, loop over the keys in numerical order and add the key to an output list a number of times based on the frequency of the key. Return the output list.","title":"Algorithm Overview:"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/#time-complexity-o-n-k","text":"","title":"Time Complexity: O (n + k)"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Counting%20Sort/#space-complexity-o-k","text":"Where k is the # of keys in the hash table and n is the input size. What if we're dealing with objects where stability matters? (Student objects, for example): ![[content/Interview Kickstart Notes/Sorting Foundations/Pasted image 20211114233536.png]]","title":"Space Complexity: O (k)"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Heapsort/","text":"Heapsort \u00b6 Extensions of Heapsort \u00b6","title":"Heapsort"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Heapsort/#heapsort","text":"","title":"Heapsort"},{"location":"Sorting%20Foundations/Sorting%20Algorithms/Heapsort/#extensions-of-heapsort","text":"","title":"Extensions of Heapsort"},{"location":"Topic%201/Note%201/","text":"Note 1 \u00b6 Example: link to Note 3 under Topic 2","title":"Note 1"},{"location":"Topic%201/Note%201/#note-1","text":"Example: link to Note 3 under Topic 2","title":"Note 1"},{"location":"Topic%201/Note%202/","text":"Note 2 \u00b6","title":"Note 2"},{"location":"Topic%201/Note%202/#note-2","text":"","title":"Note 2"},{"location":"Topic%202/Note%203/","text":"Note 3 \u00b6","title":"Note 3"},{"location":"Topic%202/Note%203/#note-3","text":"","title":"Note 3"},{"location":"Topic%202/Note%204/","text":"Note 4 \u00b6","title":"Note 4"},{"location":"Topic%202/Note%204/#note-4","text":"","title":"Note 4"}]}